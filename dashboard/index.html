<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Continuum</title>
  <style>
    :root { --fg:#0b0b0c; --muted:#6b6f76; --bg:#ffffff; --card:#f6f7f9; --line:#e7e9ee; }
    * { box-sizing:border-box; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; color:var(--fg); background:var(--bg); }
    .wrap { max-width:1100px; margin:0 auto; padding:28px 18px 50px; }
    h1 { font-size:34px; margin:0 0 6px; letter-spacing:-0.02em; }
    .sub { color:var(--muted); margin-bottom:18px; line-height:1.35; }
    .grid { display:grid; grid-template-columns: 1.15fr 0.85fr; gap:14px; }
    @media (max-width: 900px) { .grid { grid-template-columns: 1fr; } }
    .card { background:var(--card); border:1px solid var(--line); border-radius:16px; padding:14px 14px; }
    .tooltip {
  position: relative;
  cursor: help;
  border-bottom: 1px dotted #aaa;
}

.tooltip .tip {
  visibility: hidden;
  opacity: 0;
  position: absolute;
  bottom: 125%;
  left: 50%;
  transform: translateX(-50%);
  background: #111;
  color: #fff;
  padding: 8px 10px;
  border-radius: 8px;
  font-size: 12px;
  line-height: 1.4;
  width: 260px;
  z-index: 10;
  transition: opacity 0.15s ease;
}

.tooltip:hover .tip {
  visibility: visible;
  opacity: 1;
}
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:baseline; }
    .kpi { font-size:12px; color:var(--muted); text-transform:uppercase; letter-spacing:0.08em; }
    .val { font-size:20px; font-weight:600; }
    table { width:100%; border-collapse:collapse; font-size:13px; }
    th, td { padding:8px 8px; border-bottom:1px solid var(--line); text-align:left; }
    th { color:var(--muted); font-weight:600; font-size:12px; text-transform:uppercase; letter-spacing:0.06em; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; font-size:12px; }
    .log { max-height:360px; overflow:auto; background:#fff; border:1px solid var(--line); border-radius:12px; }
    .pill { display:inline-block; padding:4px 10px; border-radius:999px; background:#fff; border:1px solid var(--line); font-size:12px; color:var(--muted); }
    .ok { color:#0a6; }
    .bad { color:#c33; }
    .graph { width:100%; height:310px; border:1px solid var(--line); background:#fff; border-radius:12px; }
    .small { font-size:12px; color:var(--muted); }
    a { color:inherit; }

/* ---- Alive graph styling (colored by flow type) ---- */
svg#graph { overflow: visible; }

@keyframes breathe {
  0%, 100% { filter: drop-shadow(0 0 0px rgba(80,120,255,.0)); opacity: .92; }
  50% { filter: drop-shadow(0 0 10px rgba(80,120,255,.25)); opacity: 1; }
}

@keyframes dash {
  to { stroke-dashoffset: -1000; }
}

.graph .edge {
  stroke: #d0d4dc;
  stroke-width: 1.2;
  opacity: .55;
  stroke-dasharray: none;

}

/* Live edge baseline animation */
.graph .edge.live {
  stroke-width: 1.8;
  opacity: .95;
  stroke-dasharray: 6 10;
  animation: dash 2.2s linear infinite;
}

.graph .edge.rev.live {
  animation-direction: reverse;
}

/* Flow-type coloring (only meaningful when live) */
.graph .edge.live.salary { stroke: #2563eb; filter: drop-shadow(0 0 7px rgba(37,99,235,.28)); }
.graph .edge.live.spend  { stroke: #16a34a; filter: drop-shadow(0 0 7px rgba(22,163,74,.24)); }
.graph .edge.live.sub    { stroke: #7c3aed; filter: drop-shadow(0 0 7px rgba(124,58,237,.22)); }
.graph .edge.live.remit  { stroke: #ea580c; filter: drop-shadow(0 0 7px rgba(234,88,12,.22)); }
.graph .edge.live.drip   { stroke: #0891b2; filter: drop-shadow(0 0 7px rgba(8,145,178,.22)); }

.graph .nodeCircle {
  animation: breathe .8s ease-in-out infinite;
}

.graph .nodeCircle.employer { animation-delay: .0s; }
.graph .nodeCircle.treasury { animation-delay: .4s; }
.graph .nodeCircle.worker   { animation-delay: .8s; }
.graph .nodeCircle.merchant { animation-delay: 1.2s; }
.graph .nodeCircle.sub      { animation-delay: 1.6s; }

#tick { transition: transform 120ms ease; }

.tip{position:relative;display:inline-block;margin-left:6px;cursor:pointer;color:var(--muted)}
.tipbox{
  position:absolute;left:0;top:18px;z-index:50;
  min-width:260px;max-width:360px;
  background:#fff;border:1px solid var(--line);border-radius:10px;
  padding:10px 12px;box-shadow:0 10px 30px rgba(0,0,0,.08);
  font-size:12px;line-height:1.35;color:var(--fg);
  opacity:0;transform:translateY(-2px);pointer-events:none;
}
.tip:hover .tipbox,.tip:focus .tipbox{opacity:1;transform:translateY(0);pointer-events:auto}

  </style>
</head>
<body>
  
<section class="continuum-explainer" style="max-width: 980px; margin: 0 auto 24px; padding: 18px 18px; border: 1px solid rgba(0,0,0,0.12); border-radius: 12px;">
  <h1 style="margin: 0 0 10px; font-size: 26px; line-height: 1.2;">Continuum</h1>

  <p style="margin: 0 0 12px; font-size: 15px; line-height: 1.55;">
    <strong>Continuum is a live demonstration of governed automation without custody.</strong>
  </p>

  <p style="margin: 0 0 12px; font-size: 15px; line-height: 1.55;">
    Value moves through this system only under <strong>explicit, bounded, and revocable consent</strong>.
    No account has unrestricted transfer authority. No bot decides outcomes. No scheduler can force payments. Time advances publicly. When time advances, rules are evaluated.
    If a rule permits a transfer, it may occur. Otherwise nothing happens.
  </p>

  <h2 style="margin: 18px 0 8px; font-size: 18px;">What am I looking at?</h2>

  <div style="display: grid; grid-template-columns: 1fr; gap: 14px;">
    <div>
      <h3 style="margin: 0 0 6px; font-size: 15px;">What you’re seeing</h3>
      <ul style="margin: 0; padding-left: 18px; font-size: 14px; line-height: 1.6;">
        <li>A <strong>closed economic loop</strong> (Employer → Workers → Merchants → Treasury → Employer)</li>
        <li>Transfers executed via <strong>permissioned pulls</strong> (ERC-8102 / ERC-8103)</li>
        <li>Time enforced by a <strong>public crank</strong> (anyone can advance it)</li>
        <li>Flows that are <strong>capped, contextual, and revocable</strong></li>
        <li>No private key with <strong>free transfer authority</strong></li>
      </ul>
    </div>

    <div>
      <h3 style="margin: 0 0 6px; font-size: 15px;">What you’re not seeing</h3>
      <ul style="margin: 0; padding-left: 18px; font-size: 14px; line-height: 1.6;">
        <li>No cron job deciding payments</li>
        <li>No treasury wallet pushing funds</li>
        <li>No bot holding custody</li>
        <li>No hidden operator</li>
      </ul>
    </div>
  </div>

  <h2 style="margin: 18px 0 8px; font-size: 18px;">What this demonstrates</h2>
  <p style="margin: 0 0 10px; font-size: 15px; line-height: 1.55;">
    Continuum separates <strong>time</strong> from <strong>action</strong>.
  </p>

  <ul style="margin: 0 0 14px; padding-left: 18px; font-size: 14px; line-height: 1.6;">
    <li>Anyone may advance time</li>
    <li>No one may force execution</li>
    <li>Actions occur only when rules already allow them</li>
  </ul>

  <p style="margin: 0 0 14px; font-size: 15px; line-height: 1.55;">
    This is <strong>governed automation</strong>:
    automation where outcomes are constrained by on-chain consent, not by the discretion of an executor.
  </p>

<!--
   <h2 style="margin: 18px 0 8px; font-size: 18px;">Why is the employer balance often zero?</h2>
  <p style="margin: 0 0 10px; font-size: 15px; line-height: 1.55;">
    The employer does not hold funds. Each tick, it pulls only what it is authorized to pull and forwards it immediately to workers. No balance is retained, and no float is trusted. It acts as a conduit, not a custodian.
  </p>
-->

  <h2 style="margin: 18px 0 8px; font-size: 18px;">Verified contracts (Base Sepolia)</h2>
  <p style="margin: 0 0 10px; font-size: 14px; line-height: 1.55;">
    The core contracts below are deployed on-chain and <strong>verified</strong> on the block explorer.
    (You can inspect source, ABI, and read methods directly.)
  </p>
  <ul style="margin: 0; padding-left: 18px; font-size: 14px; line-height: 1.75;">
    <li><strong>World (ContinuumWorld)</strong>:
      <code style="font-size: 13px;">0xE40aD6D2faFCDE8BD0d3AC167b4da91dfBDCD633</code>
      — <a href="https://sepolia.basescan.org/address/0xE40aD6D2faFCDE8BD0d3AC167b4da91dfBDCD633" target="_blank" rel="noopener noreferrer">view verified source</a>
    </li>
    <li><strong>Pull Executor (RecurPullSafeV2)</strong>:
      <code style="font-size: 13px;">0x8a44B83aB5F27FAe8602ab71ab96fbe75aE399f0</code>
      — <a href="https://sepolia.basescan.org/address/0x8a44B83aB5F27FAe8602ab71ab96fbe75aE399f0" target="_blank" rel="noopener noreferrer">view verified source</a>
    </li>
    <li><strong>Consent Registry (RecurConsentRegistry)</strong>:
      <code style="font-size: 13px;">0x9AB39530b60A93d9e293300D1e59Ebd2C332Ab51</code>
      — <a href="https://sepolia.basescan.org/address/0x9AB39530b60A93d9e293300D1e59Ebd2C332Ab51" target="_blank" rel="noopener noreferrer">view verified source</a>
    </li>
    <li><strong>Token (MockUSD)</strong>:
      <code style="font-size: 13px;">0x61cFDf69f0c655eF117E415Dea08F618De55D4b2</code>
      — <a href="https://sepolia.basescan.org/address/0x61cFDf69f0c655eF117E415Dea08F618De55D4b2" target="_blank" rel="noopener noreferrer">view verified source</a>
    </li>
  </ul>

  <p style="margin: 14px 0 0; font-size: 13px; line-height: 1.5; opacity: 0.85;">
    Note: the runner is only a public “clock hand” that calls <code>tickSafe()</code> to advance time. It does not custody funds and cannot override permissions. If it goes offline, the system pauses; on-chain state remains intact and can resume from the same tick later.
  </p>
</section>

    <div class="grid">
      <div class="card">
        <div class="row" style="justify-content:space-between;">
          <div>
            <div class="kpi">Status</div>
            <div class="val"><span id="status" class="pill">connecting…</span></div>
          </div>
          <div>
            <div class="kpi">Running for</div>
            <div class="val" id="uptime">—</div>
          </div>
          <div>
            <div class="kpi">Tick</div>
            <div class="val" id="tick">—</div>
          </div>
          <div>
            <div class="kpi">Tick rate</div>
            <div class="val" id="tickrate">—</div>

<div>

  <div class="kpi">Observed time advances</div>

  <div class="val" id="observedticks">—</div>



<div>

  <div class="kpi">Observed pulls</div>

  <div class="val" id="observedpulls">—</div>



</div>



<div>

  <div class="kpi">

    Consent horizon

    <span class="tip" tabindex="0">ⓘ

      <span class="tipbox">

        Time remaining until the next authorization expires.

        When a consent expires, its flows automatically stop.

      </span>

    </span>

  </div>

  <div class="val" id="consentHorizon">—</div>

</div>



</div>



          </div>
        </div>

                <!-- Wall time vs Economic time -->
        <div style="height:12px;"></div>
        <div class="card" style="background:#fff; padding:12px; border-radius:14px;">
          <div class="kpi" style="margin-bottom:6px;">Time</div>

          <div class="row" style="justify-content:space-between;">
            <div>
              <div class="kpi">Wall time</div>
              <div class="val" id="wallTime">—</div>
            </div>
            <div>
              <div class="kpi">Economic time</div>
              <div class="val" id="econTime">—</div>
            </div>
            <div>
              <div class="kpi">Non-advancing time</div>
              <div class="val" id="pausedTime">—</div>
            </div>
            <div>
              <div class="kpi">
  <span class="tooltip">
    Efficiency ⓘ
    <span class="tip">
      <strong>Efficiency = Economic time ÷ Wall time</strong><br><br>
      Shows how much real time resulted in valid on-chain ticks. Low efficiency means the system safely paused; not that it failed.<br>
      
    </span>
  </span>
</div>
              <div class="val" id="efficiency">—</div>
            </div>
          </div>

          <div class="small" style="margin-top:8px;">
            Wall time always moves. Economic time advances only when on-chain rules permit action.
          </div>
        </div>

        <div style="height:14px;"></div>
        <div class="kpi">Flow view</div>
        <svg id="graph" class="graph" viewBox="0 0 900 360" preserveAspectRatio="none"></svg>
        <div class="small" style="margin-top:8px;">
          Public crank advances time; agents execute PPO pulls as the authorized grantee (caller == receiver). Grey = permitted • Dashed = active in recent ticks
        </div>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between;">
          <div>
            <div class="kpi">Shock test</div>
            <div class="val" id="shock">armed (tick 5)</div>
          </div>
          <div class="pill" id="contracts">contracts: —</div>
        </div>

        <div style="height:10px;"></div>
      <div class="kpi">
  Balances
  <span class="tip" tabindex="0" aria-label="Why employer is often 0?">ⓘ
    <span class="tipbox">
      The employer doesn’t hold funds. Each tick it pulls only what it is authorized to pull and forwards it immediately.
      It acts as a conduit, not a custodian.
    </span>
  </span>
</div>
        <div style="height:6px;"></div>
        <div class="log">
          <table id="balances">
            <thead><tr><th>Agent</th><th>Balance</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>

        <div style="height:14px;"></div>
        <div class="kpi">Recent events</div>
        <div style="height:6px;"></div>
        <div class="log">
          <table id="events">
            <thead><tr><th>Type</th><th>Details</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>

    <div style="height:14px;"></div>
    <div class="small">
      Tip: open <span class="mono">/state</span> to inspect the live JSON snapshot.
    </div>
  </div>

<script>

// ---- Consent horizon tracking ----

// authHash -> validBefore (ms)
let activeConsents = new Map();

function updateConsentsFromEvents(recentEvents) {
  if (!Array.isArray(recentEvents)) return;

  for (const ev of recentEvents) {
    if (ev.type === "AuthorizationCreated" && ev.authHash && ev.validBefore) {
      // validBefore expected as unix seconds
      activeConsents.set(ev.authHash, ev.validBefore * 1000);
    }

    if (ev.type === "AuthorizationRevoked" && ev.authHash) {
      activeConsents.delete(ev.authHash);
    }
  }
}

function computeConsentHorizon() {
  const now = Date.now();
  let soonest = Infinity;

  for (const expiryMs of activeConsents.values()) {
    if (expiryMs > now && expiryMs < soonest) {
      soonest = expiryMs;
    }
  }

  if (soonest === Infinity) return null;
  return soonest - now;
}

function renderConsentHorizon() {
  const el = document.getElementById("consentHorizon");
  if (!el) return;

  const remainingMs = computeConsentHorizon();

  if (remainingMs === null) {
    el.textContent = "—";
    return;
  }

  if (remainingMs <= 0) {
    el.textContent = "expired";
    return;
  }

  el.textContent = fmtDuration(remainingMs);
}

  const safeNum = (x) => {
  const n = Number(x);
  return Number.isFinite(n) ? n : 0;
};

const comma = (n) => {
  try { return safeNum(n).toLocaleString("en-US"); }
  catch { return String(n); }
};

// ---- Observed counters (session + optional persistence) ----
let observedPulls = 0;
let observedTicks = 0;

// We dedupe pulls by tx+logIndex (best), or by a composite key if logIndex missing.
// We dedupe ticks by tx (each tickSafe is one tx).
let seenPullKeys = new Set();
let seenTickTx = new Set();

// persist across refresh (recommended)
try {
  observedPulls = safeNum(localStorage.getItem("observedPulls"));
  observedTicks = safeNum(localStorage.getItem("observedTicks"));
  seenPullKeys = new Set(JSON.parse(localStorage.getItem("seenPullKeys") || "[]"));
  seenTickTx = new Set(JSON.parse(localStorage.getItem("seenTickTx") || "[]"));
} catch { /* ignore */ }

function saveObserved() {
  try {
    localStorage.setItem("observedPulls", String(observedPulls));
    localStorage.setItem("observedTicks", String(observedTicks));
    // cap sets to avoid unbounded growth
    localStorage.setItem("seenPullKeys", JSON.stringify(Array.from(seenPullKeys).slice(-8000)));
    localStorage.setItem("seenTickTx", JSON.stringify(Array.from(seenTickTx).slice(-4000)));
  } catch { /* ignore */ }
}

// ---- Core counting ----
function accumulateObservedFromRecentEvents(recentEvents) {
  if (!Array.isArray(recentEvents) || recentEvents.length === 0) return;

  for (const ev of recentEvents) {
    const type = ev?.type || "";
    const tx = ev?.tx || "";
    const logIndex = ev?.logIndex;

    // Count ticks: use the tick tx if the runner emits it as a Tick event
    // If you don't have a Tick event type, we can still infer ticks by counting unique txs
    // that include any event emitted during tickSafe.
    if (tx) {
      if (!seenTickTx.has(tx)) {
        seenTickTx.add(tx);
        observedTicks += 1;
      }
    }

    // Count pulls: PullExecuted + PullExecutedDirect
    if (type === "PullExecuted" || type === "PullExecutedDirect") {
      // Best key: tx:logIndex
      let key = "";
      if (tx && (logIndex !== undefined && logIndex !== null)) {
        key = `${tx}:${logIndex}`;
      } else {
        // Fallback composite if logIndex isn't available from runner
        key = `${tx}|${type}|${ev?.authHash || ""}|${ev?.grantor || ""}|${ev?.grantee || ""}|${ev?.amount || ""}|${ev?.blockNumber || ""}`;
      }

      if (!seenPullKeys.has(key)) {
        seenPullKeys.add(key);
        observedPulls += 1;
      }
    }
  }

  saveObserved();
}

// Persistent counter across polls (no state.json changes required)
let totalPulls = 0;
let seenPullTx = new Set(); // dedupe by tx hash (best-effort)

// If you want persistence across refreshes, uncomment these 2 lines:
// totalPulls = safeNum(localStorage.getItem("totalPulls"));
// seenPullTx = new Set(JSON.parse(localStorage.getItem("seenPullTx") || "[]"));

function countPullsFromRecentEvents(recentEvents) {
  if (!Array.isArray(recentEvents) || recentEvents.length === 0) return;

  for (const ev of recentEvents) {
    const t = ev?.type || "";
    if (t !== "PullExecuted" && t !== "PullExecutedDirect") continue;

    // Dedupe: use tx hash if available; else fall back to a composite key
    const key =
      ev?.tx ||
      `${t}|${ev?.authHash || ""}|${ev?.grantor || ""}|${ev?.grantee || ""}|${ev?.amount || ""}|${ev?.blockNumber || ""}`;

    if (seenPullTx.has(key)) continue;
    seenPullTx.add(key);
    totalPulls += 1;
  }

  // If you want persistence across refreshes, uncomment:
  // localStorage.setItem("totalPulls", String(totalPulls));
  // localStorage.setItem("seenPullTx", JSON.stringify(Array.from(seenPullTx).slice(-5000)));
}


const fmt = (n) => {
  try {
    // balances are 18 decimals
    const s = BigInt(n).toString();
    if (s.length <= 18) return "0." + s.padStart(18,"0").slice(0,6);
    const head = s.slice(0, s.length-18);
    const tail = s.slice(s.length-18, s.length-12);
    return head + "." + tail;
  } catch { return String(n); }
};

function uptimeStr(sec) {
  const d = Math.floor(sec/86400);
  sec -= d*86400;
  const h = Math.floor(sec/3600);
  sec -= h*3600;
  const m = Math.floor(sec/60);
  const s = sec - m*60;
  const parts = [];
  if (d) parts.push(d+"d");
  if (d || h) parts.push(h+"h");
  parts.push(m+"m");
  parts.push(s+"s");
  return parts.join(" ");
}

  function fmtDuration(ms) {
  ms = Math.max(0, Math.floor(ms));
  const s = Math.floor(ms / 1000);
  const d = Math.floor(s / 86400);
  const h = Math.floor((s % 86400) / 3600);
  const m = Math.floor((s % 3600) / 60);
  const sec = s % 60;

  const parts = [];
  if (d) parts.push(d + "d");
  if (d || h) parts.push(h + "h");
  parts.push(m + "m");
  parts.push(sec + "s");
  return parts.join(" ");
}

function renderTime(state) {
  if (!state) return;

  const nowMs = Date.now();

  // startedAt in your /state is unix seconds
  const startedAtMs = state.startedAt ? state.startedAt * 1000 : null;

  // lastTickAt appears to be unix ms in your /state (13 digits), but handle seconds too
  let lastTickAtMs = null;
  if (state.lastTickAt) lastTickAtMs = state.lastTickAt > 1e12 ? state.lastTickAt : state.lastTickAt * 1000;

  const tickCount = Number(state.tickCount || 0);
  const tickMs = Number(state.tickMs || 0);

  if (!startedAtMs || !tickMs) return;

  const wallMs = nowMs - startedAtMs;
  const econMs = tickCount * tickMs;
  const pausedMs = Math.max(0, wallMs - econMs);
  const eff = wallMs > 0 ? (econMs / wallMs) : 0;

  const wallEl = document.getElementById("wallTime");
  const econEl = document.getElementById("econTime");
  const pausedEl = document.getElementById("pausedTime");
  const effEl = document.getElementById("efficiency");

  if (wallEl) wallEl.textContent = fmtDuration(wallMs);
  if (econEl) econEl.textContent = fmtDuration(econMs);
  if (pausedEl) pausedEl.textContent = fmtDuration(pausedMs);
  if (effEl) effEl.textContent = (eff * 100).toFixed(1) + "%";
}

function short(a) {
  if (!a) return "";
  return a.slice(0,6) + "…" + a.slice(-4);
}

function setStatus(ok) {
  const el = document.getElementById("status");
  el.textContent = ok ? "live" : "offline";
  el.className = "pill " + (ok ? "ok" : "bad");
}

function renderBalances(state) {
  const rows = [];
  const add = (name, obj) => rows.push({ name, bal: obj.balance, addr: obj.address });
  if (state.agents?.treasury) add("treasury", state.agents.treasury);
  if (state.agents?.employer) add("employer", state.agents.employer);
  (state.agents?.merchants ?? []).forEach((m,i)=>add("merchant"+(i+1), m));
  (state.agents?.subs ?? []).forEach((s,i)=>add("sub"+(i+1), s));
  (state.agents?.workers ?? []).forEach((w,i)=>add("worker"+(i+1), w));

  const tb = document.querySelector("#balances tbody");
  tb.innerHTML = rows.map(r =>
    `<tr><td><span class="mono">${r.name}</span> <span class="small">(${short(r.addr)})</span></td><td class="mono">${fmt(r.bal)}</td></tr>`
  ).join("");
}

function renderEvents(state) {
  const events = (state.recentEvents ?? []).slice(-20).reverse();
  const tb = document.querySelector("#events tbody");
  tb.innerHTML = events.map(ev => {
    const type = ev.type ?? "Event";
    let details = "";
    if (type === "PullExecuted") {
      details = `grantor ${short(ev.grantor)} → grantee ${short(ev.grantee)} | amt ${fmt(ev.amount)}`;
    } else if (type === "PullExecutedDirect") {
      details = `grantor ${short(ev.grantor)} → grantee ${short(ev.grantee)} | amt ${fmt(ev.amount)}`;
    } else if (type === "AuthorizationRevoked") {
      details = `auth ${short(ev.authHash)} revoked by ${short(ev.grantor)}`;
    } else if (type === "EdgeFailed") {
      details = `edge ${ev.edgeId} failed: ${ev.reason || "revert"}`;
    } else if (type === "EdgeExecuted") {
      details = `edge ${ev.edgeId} executed | amt ${fmt(ev.amount)}`;
    } else {
      details = (ev.tx ? `tx ${short(ev.tx)}` : "");
    }
    return `<tr><td class="mono">${type}</td><td class="mono">${details}</td></tr>`;
  }).join("");
}

let liveEdgesUntil = new Map();     // edgeKey -> ms timestamp
let liveEdgesType  = new Map();     // edgeKey -> "salary" | "spend" | "sub" | "remit" | "drip"

function edgeKey(from, to) { return `${from}->${to}`; }

function classifyEdge(fromId, toId) {
  if (fromId === "employer" && toId.startsWith("w")) return "salary";
  if (fromId.startsWith("w") && toId.startsWith("m")) return "spend";
  if (fromId.startsWith("w") && toId.startsWith("s")) return "sub";
  if (fromId.startsWith("m") && toId === "treasury") return "remit";
  if (fromId === "treasury" && toId === "employer") return "drip";
  return ""; // unknown / other
}

function buildAddrToNodeId(state) {
  const m = new Map();
  const a = state.agents || {};
  if (a.employer?.address) m.set(a.employer.address.toLowerCase(), "employer");
  if (a.treasury?.address) m.set(a.treasury.address.toLowerCase(), "treasury");

  (a.workers || []).forEach((w,i)=>{ if (w?.address) m.set(w.address.toLowerCase(), `w${i}`); });
  (a.merchants || []).forEach((x,i)=>{ if (x?.address) m.set(x.address.toLowerCase(), `m${i}`); });
  (a.subs || []).forEach((x,i)=>{ if (x?.address) m.set(x.address.toLowerCase(), `s${i}`); });

  return m;
}

function markLiveEdgesFromEvents(state) {
  const now = Date.now();
  const addrToId = buildAddrToNodeId(state);
  const evs = state.recentEvents || [];

  for (const ev of evs) {
    const t = ev?.type || "";
    if (t !== "PullExecuted" && t !== "PullExecutedDirect") continue;

    const from = (ev.grantor || "").toLowerCase();
    const to   = (ev.grantee || "").toLowerCase();

    const fromId = addrToId.get(from);
    const toId   = addrToId.get(to);

    if (fromId && toId) {
      const k = edgeKey(fromId, toId);
      liveEdgesUntil.set(k, now + 900);

      const typ = classifyEdge(fromId, toId);
      if (typ) liveEdgesType.set(k, typ);
    }
  }

  // cleanup old
  for (const [k, until] of liveEdgesUntil.entries()) {
    if (until < now) {
      liveEdgesUntil.delete(k);
      liveEdgesType.delete(k);
    }
  }
}

function renderGraph(state) {
  const svg = document.getElementById("graph");
  svg.classList.add("graph");

  const W = 900, H = 360;
  svg.innerHTML = "";

  // Nodes
  const nodes = [];
  const addNode = (id, label, x, y, cls) => nodes.push({id,label,x,y,cls});

  addNode("employer","Employer", 170, 90, "employer");
  addNode("treasury","Treasury", 170, 270, "treasury");

  const wcount = (state.agents?.workers ?? []).length || 10;
  for (let i=0;i<wcount;i++){
    const x = 420 + (i%5)*90;
    const y = 60 + Math.floor(i/5)*90;
    addNode("w"+i, "W"+(i+1), x, y, "worker");
  }

  const mcount = (state.agents?.merchants ?? []).length || 3;
  for (let i=0;i<mcount;i++){
    addNode("m"+i, "M"+(i+1), 700, 210 + i*45, "merchant");
  }

  const scount = (state.agents?.subs ?? []).length || 2;
  for (let i=0;i<scount;i++){
    addNode("s"+i, "S"+(i+1), 700, 80 + i*45, "sub");
  }

  // Edges (conceptual)
  const edges = [];
  for (let i=0;i<wcount;i++) edges.push(["employer","w"+i]);
  for (let i=0;i<wcount;i++) for (let j=0;j<mcount;j++) edges.push(["w"+i,"m"+j]);
  for (let i=0;i<wcount;i++) for (let j=0;j<scount;j++) edges.push(["w"+i,"s"+j]);
  for (let j=0;j<mcount;j++) edges.push(["m"+j,"treasury"]);
  edges.push(["treasury","employer"]);

  const nodeById = Object.fromEntries(nodes.map(n=>[n.id,n]));

  const makePath = (x1,y1,x2,y2) => {
    const dx = (x2-x1), dy=(y2-y1);
    const c1x = x1 + dx*0.35, c1y = y1 + dy*0.05;
    const c2x = x1 + dx*0.65, c2y = y1 + dy*0.95;
    return `M ${x1} ${y1} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${x2} ${y2}`;
  };

  // Edge layer
  edges.slice(0, 260).forEach(([a,b])=>{
    const A=nodeById[a], B=nodeById[b];
    if (!A || !B) return;

    const p = document.createElementNS("http://www.w3.org/2000/svg","path");
    p.setAttribute("d", makePath(A.x,A.y,B.x,B.y));
    p.setAttribute("fill","none");
    const k = edgeKey(a,b);
const isLive = liveEdgesUntil.has(k);
const typ = liveEdgesType.get(k) || "";

const isMerchantToTreasury = a.startsWith("m") && b === "treasury";

const revClass = isMerchantToTreasury ? " rev" : "";



p.setAttribute("class", "edge" + (isLive ? " live" : "") + revClass + (isLive && typ ? " " + typ : ""));
    svg.appendChild(p);
  });

  // Node layer
  nodes.forEach(n=>{
    const g = document.createElementNS("http://www.w3.org/2000/svg","g");

    const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
    c.setAttribute("cx", n.x);
    c.setAttribute("cy", n.y);
    c.setAttribute("r", 14);
    c.setAttribute("fill", "#ffffff");
    c.setAttribute("stroke", "#cfd5df");
    c.setAttribute("class", `nodeCircle ${n.cls}`);
    g.appendChild(c);

    const t = document.createElementNS("http://www.w3.org/2000/svg","text");
    t.setAttribute("x", n.x);
    t.setAttribute("y", n.y+4);
    t.setAttribute("text-anchor","middle");
    t.setAttribute("font-size","11");
    t.setAttribute("fill","#2c2f36");
    t.textContent = n.label;
    g.appendChild(t);

    svg.appendChild(g);
  });
}

async function poll() {
  try {
    const r = await fetch("/state", { cache:"no-store" });
    if (!r.ok) throw new Error("bad response");
    const s = await r.json();
    setStatus(true);

    document.getElementById("uptime").textContent = uptimeStr(s.uptimeSeconds || 0);
    document.getElementById("tick").textContent = String(s.tickCount ?? "—");

const tickEl = document.getElementById("tick");
tickEl.style.transform = "scale(1.03)";
setTimeout(()=>tickEl.style.transform="scale(1)", 120);

    document.getElementById("tickrate").textContent = (s.tickMs ? (s.tickMs/1000).toFixed(1)+"s" : "—");
    renderTime(s);

    const add = s.addresses || {};
    document.getElementById("contracts").textContent =
      add.pullSafe ? `PullSafe ${short(add.pullSafe)} | Registry ${short(add.registry)}` : "contracts: —";

    // shock panel
    if (s.recentEvents) {
      const shockFail = s.recentEvents.find(ev => ev.type === "EdgeFailed" && (ev.reason === "LIMIT" || ev.reason));
      if (shockFail) document.getElementById("shock").innerHTML = `over-cap attempt → <span class="ok">contained ✅</span>`;
    }

    renderBalances(s);
    renderEvents(s);

accumulateObservedFromRecentEvents(s.recentEvents);

document.getElementById("observedpulls").textContent = comma(observedPulls);
document.getElementById("observedticks").textContent = comma(observedTicks);

updateConsentsFromEvents(s.recentEvents);
renderConsentHorizon();

markLiveEdgesFromEvents(s);
renderGraph(s);

  } catch (e) {
    setStatus(false);
  }
}

poll();
setInterval(poll, 5000);
</script>
</body>
</html>
